<!DOCTYPE html>
<html>
   <head>
   <link rel="stylesheet" type="text/css" href="shapes.css">
      <script type = "text/javascript" src = "https://d3js.org/d3.v4.min.js"></script>
      <script type = "text/javascript" src = "./Heap.js"></script>

	  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
      <style>
         body { font-family: Arial; }
      </style>
   </head>

   <body>
      <div id = "svgcontainer">
         
      </div>
      
   </body>
   <script type = "text/javascript"  >
   // var Node = require('./Node');
// var DiagonalMovement = require('./DiagonalMovement');

 function Node(x, y, walkable) {
    /**
     * The x coordinate of the node on the grid.
     * @type number
     */
    this.x = x;
    /**
     * The y coordinate of the node on the grid.
     * @type number
     */
    this.y = y;
    /**
     * Whether this node can be walked through.
     * @type boolean
     */
    this.walkable = (walkable === undefined ? true : walkable);
}

function Grid(width_or_matrix, height, matrix) {
    var width;

    if (typeof width_or_matrix !== 'object') {
        width = width_or_matrix;
    } else {
        height = width_or_matrix.length;
        width = width_or_matrix[0].length;
        matrix = width_or_matrix;
    }

    /**
     * The number of columns of the grid.
     * @type number
     */
    this.width = width;
    /**
     * The number of rows of the grid.
     * @type number
     */
    this.height = height;

    /**
     * A 2D array of nodes.
     */
    this.nodes = this._buildNodes(width, height, matrix);
}

/**
 * Build and return the nodes.
 * @private
 * @param {number} width
 * @param {number} height
 * @param {Array<Array<number|boolean>>} [matrix] - A 0-1 matrix representing
 *     the walkable status of the nodes.
 * @see Grid
 */
Grid.prototype._buildNodes = function(width, height, matrix) {
    var i, j,
        nodes = new Array(height);

    for (i = 0; i < height; ++i) {
        nodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            nodes[i][j] = new Node(j, i);
        }
    }


    if (matrix === undefined) {
        return nodes;
    }

    if (matrix.length !== height || matrix[0].length !== width) {
        throw new Error('Matrix size does not fit');
    }

    for (i = 0; i < height; ++i) {
        for (j = 0; j < width; ++j) {
            if (matrix[i][j]) {
                // 0, false, null will be walkable
                // while others will be un-walkable
                nodes[i][j].walkable = false;
            }
        }
    }

    return nodes;
};


Grid.prototype.getNodeAt = function(x, y) {
    return this.nodes[y][x];
};



Grid.prototype.isWalkableAt = function(x, y) {
    return this.isInside(x, y) && this.nodes[y][x].walkable;
};


Grid.prototype.isInside = function(x, y) {
    return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
};

Grid.prototype.setWalkableAt = function(x, y, walkable) {
    this.nodes[y][x].walkable = walkable;
};


 var dir=0;
 
 
Grid.prototype.getNeighbors = function(node, diagonalMovement,endX,endY) {
    var x = node.x,
        y = node.y,
        neighbors = [],
        nodes = this.nodes;
        var test=true;

        if(endX>x)
        {
            if(endY>y)
            {
                for(var z=x;z<=endX;z++)
                {
                    if(!this.isWalkableAt(z,y))
                     {test=false;break;}
                }
                if(test)  
                {
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);
                }
                else
                {
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);

                }
            }
            else 
            {
                for(var z=x;z<=endX;z++)
                {
                    if(!this.isWalkableAt(z,y))
                     {test=false;break;}
                }
                if(test)  
                {
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);
                }
                else 
                {
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);

                }

            }
        }
        else
        {
            if(endY>y)
            {
                for(var z=x;z>=endX;z--)
                {
                    if(!this.isWalkableAt(z,y))
                     {test=false;break;}
                }
                if(test)  
                {
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);
                }

                else {
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);

                }

            }
            else 
            {
                for(var z=x;z>=endX;z--)
                {
                    if(!this.isWalkableAt(z,y))
                     {test=false;break;}
                }
                if(test) 
                 {
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                 }
                else 
                {
                    if(this.isWalkableAt(x,y-1))    neighbors.push(nodes[y - 1][x]);
                    if(this.isWalkableAt(x+1,y))    neighbors.push(nodes[y][x + 1]);
                    if(this.isWalkableAt(x,y+1))    neighbors.push(nodes[y + 1][x]);
                    if(this.isWalkableAt(x-1,y))    neighbors.push(nodes[y][x - 1]);

                }
        }
    }

    //     if (this.isWalkableAt(x, y + 1)) {
    //     neighbors.push(nodes[y + 1][x]);
    //     if(dir==1) console.log("ok down");
    // }
    //     if (this.isWalkableAt(x + 1, y)) {
    //     neighbors.push(nodes[y][x + 1]);
    //     if(dir==1) console.log("ok right");

    // }
    // // ↑
    // if (this.isWalkableAt(x, y - 1)) {
    //     neighbors.push(nodes[y - 1][x]);
    //     if(dir==1) console.log("ok up");
    // }
    // // →
    
    // // ↓
    
    // // ←
    // if (this.isWalkableAt(x - 1, y)) {
    //     neighbors.push(nodes[y][x - 1]);
    // }
    return neighbors;
}

    
Grid.prototype.clone = function() {
    var i, j,

        width = this.width,
        height = this.height,
        thisNodes = this.nodes,

        newGrid = new Grid(width, height),
        newNodes = new Array(height);

    for (i = 0; i < height; ++i) {
        newNodes[i] = new Array(width);
        for (j = 0; j < width; ++j) {
            newNodes[i][j] = new Node(j, i, thisNodes[i][j].walkable);
        }
    }

    newGrid.nodes = newNodes;

    return newGrid;
};
 function backtrace(node) {
    var path = [[node.x, node.y]];
    while (node.parent) {
        node = node.parent;
        path.push([node.x, node.y]);
    }
    return path.reverse();
}
function AStarFinder(opt) {
    opt = opt || {};
    this.allowDiagonal = false;
    this.dontCrossCorners = false;
    this.heuristic = function(dx,dy){ return dx+dy;};
    this.weight = 2;
    this.diagonalMovement = false;

    
        // <!-- } else { -->
        //     <!-- if (this.dontCrossCorners) { -->
        //         <!-- this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles; -->
        //     <!-- } else { -->
        //         <!-- this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle; -->
        //     <!-- } -->
        // <!-- } -->
    

    // When diagonal movement is allowed the manhattan heuristic is not
    //admissible. It should be octile instea
}

function calculWeight(x,y,endx,endy,grid)
{
    var firsty=y;
    var firstx=x;
    var z;var test=false;
    if(x<endx) 
    {
        z=x;
        x=endx;
        endx=z;
    }

    if(y<endy)
    {
        z=y;
        y=endy;
        endy=z;
    }
    if(x!==endX)
    {

    for(z=x;z<=endx;z++)
    {
        if(!grid.isWalkableAt(z,firsty))
        return 1000;
    }
    for(z=y;z<=endy;z++)
    {
        if(!grid.isWalkableAt(firstx,z))
        return 1000;
    }
    return 3;
   

}
return 3;
}

/**
 * Find and return the the path.
 * @return {Array<Array<number>>} The path, including both start and
 *     end positions.
 */
AStarFinder.prototype.findPath = function(startX, startY, endX, endY, grid) {
    var openList = new Heap(function(nodeA, nodeB) {
            return nodeA.f - nodeB.f;
        }),
        startNode = grid.getNodeAt(startX, startY),
        endNode = grid.getNodeAt(endX, endY),
        heuristic = this.heuristic,
        diagonalMovement = this.diagonalMovement,
        weight = this.weight,
        abs = Math.abs, SQRT2 = Math.SQRT2,
        node, neighbors, neighbor, i, l, x, y, ng;
    // set the `g` and `f` value of the start node to be 0
    startNode.g = 0;
    startNode.f = 0;

    // push the start node into the open list
    openList.push(startNode);
    startNode.opened = true;
    // while the open list is not empty
    while (!openList.empty()) {
        // pop the position of node which has the minimum `f` value.
        node = openList.pop();
        node.closed = true;
        // if reached the end position, construct the path and return it
        if (node === endNode) {
		   // dir=1;
            return backtrace(endNode);
        }

        // get neigbours of the current node
        neighbors = grid.getNeighbors(node, diagonalMovement,endX,endY);
        for (i = 0, l = neighbors.length; i < l; ++i) {
            neighbor = neighbors[i];

            if (neighbor.closed) {
                continue;
            }

            x = neighbor.x;
            y = neighbor.y;

            // get the distance between current node and the neighbor
            // and calculate the next g score
            ng = node.g + 1;

            // check if the neighbor has not been inspected yet, or
            // can be reached with smaller cost from the current node
            if (!neighbor.opened || ng < neighbor.g) {
                neighbor.g = ng;
                neighbor.h = neighbor.h || calculWeight(x,y,endX,endY,grid) * heuristic(abs(x - endX), abs(y - endY));
                neighbor.f = neighbor.g + neighbor.h;
                neighbor.parent = node;

                if (!neighbor.opened) {
                    openList.push(neighbor);
                    neighbor.opened = true;
                } else {
                    // the neighbor can be reached with smaller cost.
                    // Since its f value has been updated, we have to
                    // update its position in the open list
                    openList.updateItem(neighbor);
                }
            }
        } // end for each neighbor
    } // end while not open list empty

    // fail to find the path
    return [];
};


// module.exports = Grid;

//    <!-- <script type = "text/javascript" src="./BestFirstFinder.js" /> -->
//    <!-- <script type = "text/javascript" src="./DiagonalMovement.js" /> -->
//    <!-- <script type = "text/javascript" src="./Node.js" /> -->
//    <!-- <script type = "text/javascript" src="./AStarFinder.js" /> -->
//    <!-- <script type = "text/javascript" src="./Util.js" /> -->
//    <!-- <script type = "text/javascript"> -->

// <!-- var PF = require('./Grid'); -->
// <!-- var Finder = require('./BestFirstFinder'); -->

var w = 1000;
var h = 1000;
var Algorithme = new AStarFinder();
 var gridSize= [400, 200]; // number of nodes horizontally and vertically
 
        var numCols = gridSize[0],
            numRows = gridSize[1];

        var grid = new Grid(numCols, numRows);
		
		var onsearch =  function(xx,yy,x,y) {
        var gridd;
        var strt1,end1,strt2,end2;
        gridd = grid.clone();
        if(gridd.isWalkableAt(xx-8,yy)) strt2=-2;
        else strt2=1;
        if(gridd.isWalkableAt(xx+8,yy)) end2=12;
        else end2=9;
        if(gridd.isWalkableAt(xx,yy-9)) strt1=-2;
        else strt1=1;
        if(gridd.isWalkableAt(xx,yy+9)) end1=12;
        else end1=9;

		for(var i=strt1;i<end1;i++)
		for(var j=strt2;j<end2;j++)
		{
		gridd.setWalkableAt(xx-5+j,yy-5+i,true);
		}

        if(gridd.isWalkableAt(x-8,y)) strt2=-2;
        else strt2=1;
        if(gridd.isWalkableAt(x+8,y)) end2=12;
        else end2=9;
        if(gridd.isWalkableAt(x,y-9)) strt1=-2;
        else strt1=1;
        if(gridd.isWalkableAt(x,y+9)) end1=12;
        else end1=9;

		for(var i=strt1;i<end1;i++)
		for(var j=strt2;j<end2;j++)
		{
		gridd.setWalkableAt(x-5+j,y-5+i,true);
		}
        this.path = Algorithme.findPath(
            xx, yy, x, y, gridd
        );
        for(var i=0;i<10;i++)
        {
            if( (this.path[0][0]<xx+5 && this.path[0][0]>xx-5 ) && (this.path[0][1]<yy+5 && this.path[0][1]>yy-5)) this.path.shift();
            if( (this.path[this.path.length-1][0]<x+5 && this.path[this.path.length-1][0]>x-5 ) && (this.path[this.path.length-1][1]<y+5 && this.path[this.path.length-1][1]>y-5)) 
            this.path.pop();
        }
       freeline(lineGenerator(this.path));
		//d3.selectAll("rect").style("fill","#ffffff");
		};
		
var svg = d3.select("#svgcontainer").append("svg")
         .attr("preserveAspectRatio", "xMinYMin meet")
         .attr("viewBox", "-20 -20 " + w + " " + h)
         //this is to zoom out
         //.attr("viewBox", "-20 -20 1600 1600")
         .style("padding", 5)
         .style("margin", 5)
		 .on("click",function(d)
		 { var XX,YY;
		 var mouse = d3.mouse(this);
		 mouse[0]=Math.floor(mouse[0]);
		 //console.log(mouse[0]%50);
		 if(mouse[0]%50 > 25)
		    XX = ((Math.floor(mouse[0]/50) + 1)*50 -25) ;
         else 
            XX = Math.floor(mouse[0]/50)*50 -25 ;
		 if(mouse[1]%50 > 25)
		    YY = (Math.floor(mouse[1]/50) +1 )*50 -25 ;
         else 
            YY = (Math.floor(mouse[1]/50)*50 -25) ;
			
		 if(!grid.isWalkableAt (XX/5+5-10,YY/5+5-10) || !grid.isWalkableAt (XX/5+5-10,YY/5+5+10) 
           || !grid.isWalkableAt (XX/5+5-10,YY/5+5) || !grid.isWalkableAt (XX/5+5,YY/5+5-10) ||
           !grid.isWalkableAt (XX/5+5,YY/5+5+10) || !grid.isWalkableAt (XX/5+5+10,YY/5+5-10) || 
           !grid.isWalkableAt (XX/5+5+10,YY/5+5) || !grid.isWalkableAt (XX/5+5+10,YY/5+5+10))
           return ;

		 for(var i = -2;i< 12;i++)
		   for(var j =-2;j<12 ;j++){
		    grid.setWalkableAt(j+XX/5,i+YY/5,false);
			}
			
			dragrect(XX,YY);
			//console.log(grid.getNodeAt(10,10));
		 });

var xScale = d3.scaleLinear()
             //accepts
             .domain([0, 100])
             //outputs
             .range([0, w]);

var yScale = d3.scaleLinear()
             //accepts
             .domain([0, 100])
             //outputs
             .range([0, h]);
			 
			 //PREPARE AXES  
var xAxisBottom = d3.axisBottom(xScale).ticks(20);  
var xAxisTop = d3.axisTop(xScale).ticks(20);    
var yAxisLeft = d3.axisLeft(yScale).ticks(20);  
var yAxisRight = d3.axisRight(yScale).ticks(20);        
                
//<!-- //DRAW AXES -->
// <!-- svg.append("g") -->
// <!-- .attr("class", "axis")  -->
// <!-- .attr("transform", "translate(0," + h + ")") -->
// <!-- .call(xAxisBottom); -->

// <!-- svg.append("g") -->
// <!-- .attr("class", "axis") -->
// <!-- .call(xAxisTop); -->

// <!-- svg.append("g") -->
// <!-- .attr("class", "axis")  -->
// <!-- .call(yAxisLeft); -->

// <!-- svg.append("g") -->
// <!-- .attr("class", "axis") -->
// <!-- .attr("transform", "translate(" + w + ",0)")     -->
// <!-- .call(yAxisRight); -->

//PREPARE GRIDS
//MAIN
var ygridlines = d3.axisTop()
                 .tickFormat("")
                 .tickSize(-h)
                 .ticks(20)
                 .scale(xScale);
                
var xgridlines = d3.axisLeft()
                 .tickFormat("")
                 .tickSize(-w)
                 .ticks(20)
                 .scale(yScale);

//MINOR
var ygridlinesmin = d3.axisTop()
                    .tickFormat("")
                    .tickSize(-h)
                    .ticks(200)
                    .scale(xScale);
        
var xgridlinesmin = d3.axisLeft()
                    .tickFormat("")
                    .tickSize(-w)
                    .ticks(200)
                    .scale(yScale);
//DRAW GRIDS
//MINOR GRID
svg.append("g")
.attr("class", "minor-grid")
.call(ygridlinesmin);

svg.append("g")
.attr("class", "minor-grid")
.call(xgridlinesmin);

//MAIN GRID
svg.append("g")
.attr("class", "main-grid")
.call(ygridlines);

 svg.append("g") 
.attr("class", "main-grid")
.call(xgridlines);

// <!-- var rect = svg.append("rect") -->
//        <!-- .attr("height",function(d){ -->
//          <!-- return yScale(50);}) -->
// 	   <!-- .attr("id", "active") -->
//        <!-- .attr("width", function(d){ -->
//           <!-- return xScale(10);}) -->
//        <!-- .attr("y",function(d){ -->
//           <!-- return yScale(20);}) -->
//        <!-- .attr("x",function(d){ -->
//           <!-- return xScale(23);}) -->
//        <!-- .attr("class", "rectangle"); -->
	   
var lineGenerator = d3.line().curve(d3.curveBasis)
                    .x(function(d) { return d[0]*5 })
                    .y(function(d) { return d[1]*5 });

//var pathData = lineGenerator(points);
var freeline =(path)=>
{
     svg.append("path")
               .attr("class", "freeline")
               .style("stroke",function() {
    return "hsl(" + Math.random() * 360 + ",100%,50%)";
    })
               
               .attr("d", function(d) { return path ; });
};
			   
var drag = d3.drag()
    .on("drag", dragmove);
var startX=0,startY=0;
var dragrect =(x,y)=>
{ svg.append("rect")
      .attr("id", "active")
      .attr("x", function(d) { return x; })
      .attr("y", function(d) { return y; })
	  .attr("centreX",x+25)
	  .attr("centreY",y+25)
      .attr("height", yScale(5))
      .attr("width", xScale(5))
	  .attr("stroke","#000000")
	  .attr("stroke-width","1")
      .attr("cursor", "move")
	  .on("mouseover", function() {
            d3.select(this)
            	.attr("fill", "black");
        })
        .on("mouseout", function(d, i) {
            d3.select(this).attr("fill", function() {
                return "" + "#ffffff" + "";
            });
        })
    //   .call(drag)
	  .on("contextmenu", function(d,i) {
	  d3.event.preventDefault();
  
 
  d3.event.stopPropagation();
	  if(!startX)
	  {
        startX = d3.select(this).attr("centreX");
	    startY = d3.select(this).attr("centreY");
	   d3.select(this).attr("fill-opacity",1);
	   }
	   else 
	   {
	     endX = d3.select(this).attr("centreX");
	    endY = d3.select(this).attr("centreY");
	   d3.select(this).attr("fill-opacity",1);
	   d3.select(this).attr("fill","green");
	   //finding the path 
	   onsearch(startX/5,startY/5,endX/5,endY/5);
	   startX=startY=0;
	   }
  
});

}
	function dragmove(d) {
  
    
    var xx = (d3.event.x-30) - (d3.event.x)%50 +5;
	    var yy = (d3.event.y-30) - (d3.event.y)%50  +  5;

	for(var i = -2;i< 12;i++)
		   for(var j =-2;j<12 ;j++){
		    grid.setWalkableAt(j+d3.select(this).attr("x")/5,i+d3.select(this).attr("y")/5,true);
		    grid.setWalkableAt(j+xx/5,i+yy/5,false);
			} 
      d3.select(this)
          .attr("x", function(d) { return Math.max(0, Math.min(800 - xScale(5), xx))})
          .attr("centreX", xx+25);
		
      /*dragbarleft 
          .attr("x", function(d) { return d.x - (dragbarw/2); })
      dragbarright 
          .attr("x", function(d) { return d.x + width - (dragbarw/2); })
      dragbartop 
          .attr("x", function(d) { return d.x + (dragbarw/2); })
      dragbarbottom 
          .attr("x", function(d) { return d.x + (dragbarw/2); })*/
  
       d3.select(this)
          .attr("y", function(d) { ;return  Math.max(0, Math.min(800 - yScale(5),yy))})
		  .attr("centreY", yy+25)

      /*dragbarleft 
          .attr("y", function(d) { return d.y + (dragbarw/2); });
      dragbarright 
          .attr("y", function(d) { return d.y + (dragbarw/2); });
      dragbartop 
          .attr("y", function(d) { return d.y - (dragbarw/2); });
      dragbarbottom 
          .attr("y", function(d) { return d.y + height - (dragbarw/2); });*/
  
}

</script>
</html>
